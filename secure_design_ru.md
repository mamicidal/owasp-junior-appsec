# Secure Design Principles

В прошлой статье мы разобрали как составлять требования к безопасности, используя такие техники, как Security & Abuser истории,
научились моделировать риски с помощью STRIDE и DREAD, а также структурировали с помощью этих техник модель FAIR.

Теперь на этапе проектирования наша цель - определить **принципы безопасности**, которые будут использоваться в нашей системе,
на основе собранных нами требований к безопасности.

В этой статье мы рассмотрим не только одни из самых важных принципов проектирования, но и как обеспечить общую **устойчивость** системы безопасности и архитектуры.

## 1. Принципы проектирования
### Принцип наименьших привилегий

Давай представим офис маленькой компании. У нас есть бухгалтер, маркетолог, IT-специалист и менеджер по персоналу.
Каждый занимается своими делами, коммуницируют между собой и взаимодействуют с системой через свой личный кабинет.

Компания не проводила курсы по кибер-гигиене для своих сотрудников, и на компьютер HR менеджера после открытия заразного CV файла попал вирус. Вирус украл логин и пароль от личного кабинета, и злоумышленник теперь может подключиться к системе компании от имени этого члена команды.

Но так как в компании не разделяли права, помимо информации, что находится в зоне ответственности HR менеджера, в руки злоумышленнику попала информация **всех отделов**, что существенно увеличило импакт из-за оплошности HR менеджера.

Очевидно, что последствия были бы намного меньше, если изначально каждая роль в команде имела доступ только к той информации и действиям, которая ей действительно нужна.

Тоже самое касается и сервисов, что работают в нашей системе. У них должно быть ровно столько прав, сколько им действительно нужно.
Посмотрим на примере следующей упрощенной архитектуре:

Представим у нашего приложения 5 сервисов:
- Сервис аутентификации (**Auth Service**) - Управляет входом пользователей
- Сервис пользователелей (**User Service**) - Управляет профилями пользователей
- Платежный сервис (**Payment Service**) - Отвечает за обработку платежей
- Сервис нотификаций (**Notification Service**) - Рассылает уведомления пользователям
- Сервис аналитики (**Analytics Service**) - Анализирует данные для отчетности

По принципу наименьших привилегий, в аспекте доступа данных они должны ограничены в следующем виде:
- **Auth Service** имеет доступ только к учетным записям пользователей
- **User Service** может оперировать только над профилями пользователей
- **Payment Service** - имеет доступ только к платежным данным
- **Notification Service** - только к контактным данным для рассылки уведомлений
- **Analytics Service** - доступ только к обезличенным данным пользователей

В таком случае, даже если обнаружится уязвимость в одном из сервисов, злоумышленник сможет заполучить только те данные, что касались этого сервиса.
По аналогии, этот принцип должен соблюдаться на **каждом** слое системы, от прав пользователей самого сервера, до сущностей внутри наших сервисов.

### Принцип нулевого доверия
Принцип нулевого доверия (**Zero Trust**) очень хорошо сочетается с предыдущим. Основная идея его состоит в том, что наша система не должна доверять пользователям или сервисам по умолчанию, даже если они находятся внутри корпоративной сети.

Чтобы проще понять, давай вернемся к нашему примеру с офисом. Если какой-то человек находится на территории офиса, он необязательно является членом команды, которая работает в нем, верно? Если он подойдет к бухгалтеру и запросит определенную отчетность, то сначала бухгалтер должен узнать **кто** он такой, и имеет-ли он **право** на получение это отчетности.

Точно также будут обстоять дела у нашей системы. Если внутри сети, первый сервис **A** ко обращается ко второму сервису **B**, то наш сервис **B** должен сначала **аутентифицировать** запрос, чтобы идентифицировать отправляющего, а затем **авторизовать** его, проверив имеет-ли он достаточно прав для данного действия.

Чтобы лучше понимать, как строить Zero Trust архитектуру для сервисов, рассмотрим ее на реальном примере. Для этого воспользуемся инструментами от [HashiCorp](https://www.hashicorp.com/):

- [Consul](https://www.consul.io/) - Для установки безопасного сетевого взаимодействия через mTLS, локации сервисов и выдачи сертификатов
- [Vault](https://www.vaultproject.io/) - Для аутентификации сервисов и управления ключами

Внутри **Consul** создаем роли (нпр. service-a, service-b) и настраиваем корневой сертификат. Он будет использоваться, чтобы выдавать TLS сертификаты нашим сервисам по их ACL токену. В **Vault** устанавливаем те же роли наших сервисов и указываем им политики. В качестве политик могут выступать любые значения, например можно указать права сервиса.

Наконец, импортируем в Vault корневой сертификат Consul и выставляем **TLS Auth Method** в качестве метода аутентификации. Теперь наш процесс аутентификации и авторизации сервисов будет выглядеть так:

Представим сервис **A** хочет обратиться к сервису **B**, например запросить информацию о пользователе. Для сервиса **A** в Vault мы добавили политику `com.myapp.users.access`
1. При инициализации, сервис A получает свой сертификат из **Consul**
2. Используя свой сертификат, аутентифицируется в **Vault** и получает свой временный **токен доступа**
3. Сервис **A** указывает этот токен в хедерах и отправляет запрос сервису **B**
4. Сервис **B** проверяет токен через **Vault**. Он смотрит, если у сервиса есть политика `com.myapp.users.access` и относительно этого пропускает или блокирует запрос.

Как видно, мы здесь автоматически не только аутентифицируем и авторизируем наши сервисы, но и следуем предыдущему принципу минимальных привилегий, который является неотъемлимой частью архитектуры нулевого доверия.

### Безопасный отказ
Никто не застрахован на 100% от отказа в системе. Отказ может быть вызван **программными ошибками**, **аппаратными сбоями**,
проблемами в **конфигурации**, а также **внешними атаками**.

Нам очень важно, чтобы система в случае отказа, вместо перехода в ошибочное состояние, могла его либо правильно обработать, либо оставалась в том состоянии, в котором она **не выдаст информацию** о внутреннем её устройстве.
Злоумышленники часто пытаются привести систему к отказу, как раз чтобы получить о ней технические детали. Сбор информации о системе - самый первый этап нелегитимных действий против инфраструктуры.

Неправильная обработка ошибок часто приводит к тому, что стектрейс ошибки возвращается обратно в ответе, а это в зависимости от контекста, может выдать информацию о:
- Фреймворке, на котором написано приложение
- Сервере, на котором основано приложение
- Внутреннюю структуру приложения
- Структуру базы данных (если ошибка связана с ней)

Как видно, это может привести к раскрытию важной информации о структуре всей системы.
Отказ можно назвать безопасным, если в результате:

- Не были выданы технические детали о системе
- Не нарушена целостность и конфиденциальность данных в системе
- Система продолжила бесперебойную работу
- Вся информация о нем была залогирована для дальнейшего анализа

Практики по безопасной обработке ошибок мы рассмотрим подробно в статье **Secure Coding Principles**.

### Защита в глубину
Согласитесь, странно выглядело, если система была бы защищена чем-то одним. Система не может быть безопасной, если мы грамотно спроектировали и написали приложение, но у нас хромает безопасность окружения, в котором оно работает.
Точно также и наоборот, какой смысл от безопасного окружения, если у нас дырявое приложение?

Система считается защищенной, если она обеспечивает безопасность на **каждом** слое сети, правильно определяет попытки проникновений и вовремя реагирует **инциденты**.
Этот принцип подразумевает, что защита должна быть многоуровневой, и специалисты по безопасности должны разработать соответствующие их компетенции меры.

Например, специалист по сетевой безопасности (**NetSec**) должен обеспечить **сегментацию сети**, поднять и настроить **IDS** и **IPS**, чтобы фильтровать и блокировать вредоносный трафик и установить межсетевые экраны (**Firewall**).
**AppSec** же должен разработать методики защиты уже на уровне приложения, включая применение принципов безопасного программирования.

Таким образом, если злоумышленник обошел один слой защиты, предотвратить несанкционированный доступ должен уже следующий слой.

### Аудит и логирование
Помните офис, который мы описывали в начале? Обычно в офисах в систему вписываются все посещения, выходы и установлены системы наблюдения.
А теперь представьте, что офис решил не записывать входы-выходы людей, камеры не работают, а из офиса пропали ценные вещи.

То, что вещи украли мы конечно же узнали, но на кой нам знать о факте кражи, если мы не можем узнать ни кто это сделал, ни как это сделали. Теперь нам важно не допустить подобного в нашей системе.

Отсутствие правильного аудита и логирования действий в системах нарушает один из принципов безопасности информации - **non-repudiation** (неотрекаемость). Он подразумевает, что сторона не может отрицать факт своего участия в каком-либо действии. Также их отсутствие на дает нам вовремя заметить какую-то проблему в системе.

Дла эффективного аудита и логирования в нашу систему как минимум должны быть введены следующие понятия:

#### Security Events
К данному типу событий мы будем относить все действия, которые относятся к безопасности системы, включая

* Успешные/неуспешные попытки аутентификации
* Попытки доступа к защищенному ресурсу
* Любые аномальные активности (нпр. превышение попыток доступа к аккаунту)
* Изменения прав доступов у пользователей
* Доступ к критическим файлам/системам
* Любая информация от систем безопасности на разных слоях сети (нпр. от IDS и IPS)

Для управления этими событиями, нам нужно иметь соответствующую систему, именуемая как **SIEM** (Security Information and Event Management).
Одним из лучших open-source решений является [Wazuh](https://wazuh.com/).

#### Error Events
Имя говорит за себя. Это события ошибок, которые происходят у нас в системе и в сервисах этой системы.
К ним мы относим:

- Сбои подключения (нпр. к базам данных)
- Сетевые ошибки, как разрыв соединения
- Проблемы с производительностью (например тайм-ауты)
- Неудачные попытки отправки/получения сообщений

И любые другие внутренние ошибки/исключения приложений.
Часто, особенно в небольших командах, вместо централизованных обработчиков событий ошибок, используют условную папку `logs`, в которой хранят логи событий по дням.

Это действительно удобно, если вы только локально тестируете 1 сервис и хотите быстро посмотреть, что происходит. Но если уже идет тестирование всей системы, или переходите в продовый режим, намного предпочтительнее использовать централизованные трекеры ошибок.
Нашим фаворитом является [Sentry](https://sentry.io).

Ведь это намного удобнее, если вся информация об ошибках у различных сервисов в системе, вся информация о проблемах с производительностью, собраны в одном месте, не так-ли?
### Принципы упрощенной и открытой безопасности
Мы определили, что система является защищенной, если обеспечены нужные превентивные меры на каждом слое нашей сети.
Но при реализации систем безопасности, нужно учитывать 3 основных принципа:

#### Безопасность по умолчанию
Системы и приложения должны быть изначально построены так, чтобы они были безопасны из коробки без дополнительной конфигурации.
Этот принцип нужен в первую очередь, чтобы избежать человеческой ошибки.

Вы видите пример реализации этого принципа в вашем браузере. К примеру в популярных браузеров без дополнительных настроек включены функции блокировки
всплывающих окон, имеют защиту от фишинга, и используют **HTTPS** по умолчанию.

#### Открытый дизайн
Никогда не стройте основу системы безопасности на принципе **безопасность через неизвестность**. Знание устройства безопасности в нашей системе не должно давать возможности злоумышленнику
скомпрометировать ее.

Такой же принцип мы применяем в криптографии и известен как **Принцип Керкгоффса**. Звучит он следующим образом:

*Безопасность криптографической системы должна зависить не от секретности алгоритма, а от секретности ключа.*

#### KISS
*(Keep It Simple Stupid)* - принцип, который гласит, что система и ее компоненты должны быть максимально простыми и понятными.
Более простые системы легче понять и защищать. И действительно, реализовывая тяжелые и непонятные системы, вы скорее вставите себе палки в колеса, и не сможете ее должно защитить.

Этот же принцип стоит применять не только в архитектуре нашего ПО, но и в коде приложений. Этим самым нам будет намного проще их поддерживать.

Например, если у нас одно большое монолитное приложение, лучше воспользуйтесь принципом *"Разделяй и властвуй"* и разделите его на микро-сервисы.
___

## 2. Кибер-устойчивые системы безопасности
Понимание принципов проектирования безопасности помогает нам строить системы, защищенные от многих векторов атак, включая как внешние и внутренние угрозы.

Но помимо обеспечения безопасности, нам надо убедиться, что наша система безопасности **устойчива**. Чтобы понять, как обеспечить ее устойчивость, рассмотрим **Стратегические** и **Структурные** принципы обеспечения устойчивости систем безопасности:

### Стратегические принципы
К стратегическим мы относим те принципы, которые направляют общую стратегию безопасности и устойчивости системы. Среди них выделяется 5 основных принципов:

#### Фокус на общих критических ресурсах
Помните в прошлой статье мы описывали Security & Abuser истории? Благодаря ним мы смогли определить, какие ресурсы являются критическими в первую очередь.
Организационные и программные ресурсы часто ограничены (вернее почти всегда), соответственно они должны быть направлены в первую очередь на эти ресурсы, так как там они принесут наибольшую пользу.

#### Поддержка гибкости и архитектура для адаптируемости
Безопасность - это не то, что можно просто реализовать по условному чек-листу и забыть. Это итеративный процесс, и наша система всегда должна быть готова к тому, что она может быть изменена в ответ на новые угрозы и изменений в технологической среде. Наша цель - спроектировать систему изначально так, чтобы цена изменений была минимальна.

Чтобы следовать этому принципу, старайтесь применять **модульный** подход. Разделите систему на модули, и старайтесь снизить зависимость между ними до минимума. До этого описанный принцип **KISS** в этом очень поможет.

#### Сокращение поверхностей атаки
Поверхности атаки - это места в системе, через которые атакующий попытается проникнуть в нашу систему. Это могут быть не только сервисы, которые выходят в сеть, но также и **человеческие ресурсы**. Ведь злоумышленник может использовать уязвимости не только в аспекте систем, но и атакуя конкретных людей, которые могут иметь доступ к системе. 

Наша цель в этом случае - минимизировать места, к которым может подойти злоумышленник и сфокусироваться на многоуровневой их защите.
Наши лучшие друзья - принципы минимальных привилегий, защиты в глубину и Zero Trust.

#### Любой ресурс может быть скомпрометирован
При проектировке систем, мы не должны считать что-либо на 100% безопасным. Мы всегда должны подходить к безопасности компонентов с обратной стороны, и спроектировать все так, чтобы ущерб в результате потенциальной компрометации был минимален.

Более того, системы должны оставаться способными выполнять требования по производительности и качеству, даже если некоторые их компоненты подверглись компрометации. 
Стратегии по восстановлению в случае компрометации должны быть разработаны заранее.

#### Атакующие эволюционируют
Киберпреступники постоянно развивают свои методы и подходы к атакам. И делают они часто это быстрее, чем растет уровень общей безопасности. Старайтесь при разработке мер безопасности, помимо анализа "от чего это защищает", задавать вопрос *"а как это можно это обойти?"*

Чтобы не стать жертвой атакующих, нужно разрабатывать защитные меры на несколько шагов вперед и анализировать новые потенциальные векторы атак при введение изменений в нашей системе. Более того, очень хорошей практикой является **кибер-разведка**, чтобы быть в курсе последних тенденций безопасности и методов атак.

### Структурные принципы
Описанные до этого стратегические принципы движат структурными принципами, которые мы применяем к системе. Мы опишем **9** ключевых принципов, которые обеспечат, что наша архитектура и механизмы безопасности в ней устойчивы.

#### Ограничивай необходимость доверия
Доверие к компонентам системы означает, что мы полагаемся на них для выполнения важных задач. Чем меньше компонентов, которым нужно доверять, тем лучше для безопасности системы.

В контексте сервисов, нам помогут его соблюдать **Zero Trust** и принцип наименьших привилегий. Но и при реализации даже Zero Trust архитектуры, мы уже встречались с одним из ее доверительных компонентов, 
когда описывали как с помощью HashiCorp Vault и Consul сделать Zero Trust архитектуру.

В этом случае нашим доверительным компонентом выступал **identity token** и чем меньше срок его действия, тем более безопасным это для нас является.

#### Контролируй видимость и использование
Этот принцип направлен на то, чтобы помешать атакующему проводить будь-то внешнюю или внутреннюю разведку системы.

Здесь мы можем выделить 3 условия, при которых мы его должны применять:

1. Когда данные должны быть защищены от несанкционированного доступа:\
    Для этого мы шифруем эти данные, для хранения и передачи, или токенизируем и обфусцируем их.
2. Когда необходимо усложнить анализ сетевого трафика:\
    Здесь мы используем методику известную как "Chaffing & Winnowing", проще говоря, добавляем шумы в трафик и в передаваемые данные.
3. Когда необходимо защитить процесс разработки и цепочку поставок:\
    Это находится в зоне компетенции **OPSEC**. Но как правило, применяются известные нам принципы, как **принцип минимальных привилегий** и шифрование передаваемых данных.

#### Содержи и исключай поведения
Этот принцип помогает контролировать и ограничивать поведение систем и их компонентов, чтобы предотвратить нежелательные действия и минимизировать вред от них. Грубо говоря, наша цель - контролировать действия злоумышленников, даже если они смогли проникнуть в систему. Мы должны
ограничить что они смогут сделать и куда добраться:

1. **Исключение недопустимого поведения**:\
    Мы можем определить виды поведений, которые происходить **не должны**. Приведем банальный пример с CRM типичного магазина. Если время работы магазина с 08:00-18:00, то логично, надо запретить любые входы в панель вне этого промежутка.

2. **Содержание подозрительного поведения**:\
    Принцип до безумия простой. Если обнаружены какие-то подозрительные действия, мы должны создать изолированную среду, в которой можем их проанализировать. Например, если загружается подозрительный файл, мы можем запустить его в отдельной песочнице для его анализа.

3. **Динамическая сегментация и изоляция**:\
    Представим, что обнаружен подозрительный трафик. Система должна перенаправить этот трафик в изолированную среду, где мы можем его безопасно проанализировать.

Чтобы грамотно изучать поведенченский характер и автоматическое обнаружение подозрительной активности, хорошей практикой является поднятие отдельных изолированных сред, известные как **Honeypot**. В этой среде мы полностью сможем проанализировать, что злоумышленник хочет сделать и понять ход его мыслей.

#### Планируй и управляй разнообразием
Я до этого описывал важность принципа **KISS** в архитектуре и системах безопасности, но бывают случаи, когда намеренное усложнение дает преимущества. Один из примеров описывает этот принцип - а именно опасность **однородных** систем. Здесь важно найти баланс:

Разнообразие помогает защитить систему от атак, которые могут быть успешными против однородных систем. Использование различных технологий и методов снижает вероятность того, что одна уязвимость приведет к компрометации всей системы.

Например, для критически важных сервисов можно использовать разные операционные системы, на которых они работают, чтобы нельзя было воспользоваться единой уязвимостью на обеих. Это особенно релевантно, если вдруг обнаружатся уязвимости в стилистике **Buffer Overflow**, где успех выполнения инструкций очень зависит от архитектуры, на которой работает приложение и OS.
Разные ОС и архитектуры могут по-разному обрабатывать память, что затрудняет использование одной и той же уязвимости на разных системах.

Можно использовать разные Cloud провайдеры, чтобы в случае недоступности одного, часть сервисов была все также доступна, будучи развернутыми в другом провайдере.

#### Поддерживай избыточность 
Помните третий принцип CIA триады - **доступность**, который мы говорили в самой первой статье? Вот этот принцип - избыточность помогает избежать отказов и сбоев в работе системы. В случае выхода из строя одного компонента, другой компонент может взять на себя его функции, обеспечивая непрерывность работы системы.

Мы часто применяем избыточность, когда мы хотим **балансировать** активность на сервере. Проектирование компонента системы с поддержкой **горизонтального масштабирования** позволит просто запустить второй такой же компонент, если не справляется один, или он лег из-за отказа.

#### Управляй ресурсами адаптивно
Мы же хотим, чтобы наша система была гибкой? В таком случае и среда, в которой она работает, должна сама **адаптироваться** к изменениям в реальном времени. Она должна быстро реагировать на изменения и минимизировать последствия в том числе и сбоев.

Например, в случае обнаружение угроз, правила межсетевых экранов и систем безопасности могут меняться в ответ на вторжения. Или не будем далеко ходить, приведем пример со случаем банальной авторизации - если замечено, что пользователь пытается зайти из незнакомого места, даже в случае верно введенного логин пароля нам нужно дополнительно его аутентифицировать (нпр. через email).

#### Определяй текущую надежность
Не полагайтесь на стабильность компонентов со временем, а лучше регулярно проверяйте их текущую надежность. Это включает и периодическую верификацию, постоянный мониторинг, чтобы вовремя выявлять и устранять последствия потенциально вредоносных действий.

Также хорошей практикой является регулярный пен-тест системы, чтобы убеждаться в ее безопасности с течением времени. Одним из наших фаворитов для пентестинга является **OWASP ZAP**.

#### Изменяй или нарушай поверхность атаки
В случае, когда злоумышленник использует поверхность атаки (условно атакует какой-то из наших сервисов), мы можем продумать
методы, с помощью которых мы ему затрудним совершение нелегитимных действий.

Это включает в себя:
1. Динамическое изменение конфигураций системы (например смена IP адресов системы)
2. Перемещение важных данных и сервисов между различными физическими или виртуальными местоположениями.
3. Создание ложных целей, например ханипотов.

В качестве примера, представим, что злоумышленник устроил DDoS атаку. Одна из крайне эффективных по моему мнению методик по устранению атак не просто фильтрация трафика, а именно использование механизма **IP Hopper**.
Согласно этой методологии, весь легитимный трафик должен перенаправляться на тот сервер, который не находится под атакой, а нелегитимный трафик буквально атакует *пустоту*.

#### Сделай эффекты обмана и непредсказуемости прозрачными для пользователя
И наконец последний структурный принцип для создания устойчивых систем. В течение этой статьи, мы узнали много механизмов безопасности, которые могут быть спроектированы и применены.

Идея этого принципа состоит в том, что именно злоумышленники должны сталкиваться с трудностями из-за наших механизмов безопасности. Они не должны прерывать бесперебойность нашей системы для легитимных пользователей.
___

## Заключение
В данной статье мы рассмотрели ключевые принципы проектирования систем безопасности и методы обеспечения их устойчивости.

Мы прошлись по восьми принципам безопасного проектирования:
1. Принцип наименьших привилегий - Системы и ее компоненты должны иметь столько прав, сколько им нужно и не более.
2. Принцип нулевого доверия (Zero Trust) - Не доверям сервисам и пользователям, даже если они находятся внутри корпоративной сети.
3. Безопасный отказ - Обработка отказов таким образом, чтобы они не выдали внутреннюю информацию о системе.
4. Защита в глубину (Defense in Depth) - Защита не может строиться из одного слоя.
5. Аудит и логирование - Аудит, логирование событий безопасности и трекинг ошибок в реальном времени.
6. Безопасность по умолчанию - Безопасность не должна требовать дополнительной конфигурации.
7. Open Design - Безопасность системы не должна зависеть от секретности ее реализации
8. KISS - Не надо усложнять систему, так мы только усложним себе жизнь, а не улучшим безопасность.


Изучили стратегические принципы устойчивости:

1. Фокус на общих критических ресурсах
2. Поддержка гибкости и адаптируемости
3. Сокращение поверхностей атаки
4. Предположение компрометации ресурсов
5. Учёт эволюции методов атак

И разобрали структурные принципы устойчивости:

1. Ограничение необходимости доверия
2. Контроль видимости и использования
3. Содержание и исключение нежелательных поведений
4. Планирование и управление разнообразием
5. Поддержание избыточности
6. Адаптивное управление ресурсами
7. Определение текущей надежности
8. Изменение или нарушение поверхности атаки
9. Прозрачность эффектов обмана и непредсказуемости для пользователей

Таким образом, следуя принципам безопасного проектирования и принципам обеспечения устойчивости систем, мы можем спроектировать действительно безопасную архитектуру, которая готова обеспечивать защиту в среде агрессивного интернет-мира.